#ifndef GAMESTATE_H
#define GAMESTATE_H

# include "State.h"

/*
	Это класс для игрового состояния
	Тут находится всё мясо игры.

	Из жизненно важных перменных:
	указатель на игрока (такой один)
	Указатель на карту (она потом передаётся при иницилизации игрока/мобов)
	Вектор Мобов (все хранятся в одном векторе, для элементов выполняются общие методы)
	Вектор объектов (пока там только светильники, отсюда и название lights)
	Словарь в который записываются последовательные координаты мобов на респ
	(например по ключу "Zombie" у меня могут идти x1, y1, x2, y2, ...)

	Для всех классов Entity выполняются общие методы render, update, которые уточняются
	непосрдественно в конкретном классе, где может понадобится (например) логика взаимодейсвтия с картой.
	Пример: я вызываю метод update для игрока, а уже в методе update:
	а) проверяю команды на перемещение и если что, вызываю метод для перемщения (в котором учтена логика с картой)
	б) Обновляю маску видимости для карты
	в) обновляю маску освещённости игрока для карты

	Ещё для сущностей написан вирутальный метод React_on(Entity *), который задаёт реакцию на сущность 
	(пока испольущется только на игрока):
	зомби поворачивается в нужную сторону, если видет цель, лампа загорается/гаснет при команде близстоящего игрока.
	Тут снова сложная логика для каждого отдельного подкласса сущнсоти, поэтому прорписывается всё непосредственно
	в методах классов

*/


class GameState : public State{

	Entity * player;
	Map * map;
	sf::View * view;

	std::vector<Entity *> mobs = {};
	std::vector<Entity *> lights = {};
	std::map<std::string, std::vector<double>> buf;


	public:
		GameState(sf::RenderWindow * window, std::stack<State *> * states);
		~GameState();

		void update(const float & dt);
		void render(sf::RenderWindow * window = NULL);

		void updateKeybinds(const float & dt);
		void endState();
};

#endif